<!-- FOR TESTING PURPOSE -->
<!-- CODE IS GARBAGE, ONLY FOR TESTING -->
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>test</title>
		<script>
			function print(obj) {
				console.log(JSON.stringify(obj));
			}
		</script>
		<style>
			canvas {
				background-color: whitesmoke;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas3d" tabindex="1"></canvas>
		<script type="module">
			import { Scene, KObject, Tri, KCanvas, Mat } from "./src/index";

			const cvs = document.getElementById("canvas3d");
			cvs.width = window.innerWidth;
			cvs.height = window.innerHeight;

			const s = cvs.width * 0.3;
			const scene = new Scene();

			const cube = new KObject(
				[
					//top
					new Tri([0, 0, s], [s, 0, s], [0, s, s], "red"),
					new Tri([0, s, s], [s, 0, s], [s, s, s], "red"),

					//bottom
					new Tri([0, 0, 0], [s, 0, 0], [s, s, 0], "green"),
					new Tri([0, 0, 0], [0, s, 0], [s, s, 0], "green"),

					//front
					new Tri([0, 0, 0], [s, 0, 0], [s, 0, s], "blue"),
					new Tri([0, 0, 0], [0, 0, s], [s, 0, s], "blue"),

					//back
					new Tri([0, s, 0], [s, s, 0], [0, s, s], "black"),
					new Tri([s, s, 0], [0, s, s], [s, s, s], "black"),

					//left
					new Tri([0, s, 0], [0, 0, 0], [0, 0, s], "yellow"),
					new Tri([0, s, 0], [0, s, s], [0, 0, s], "yellow"),

					//right
					new Tri([s, 0, 0], [s, s, 0], [s, s, s], "purple"),
					new Tri([s, 0, 0], [s, 0, s], [s, s, s], "purple"),
				],
				[-s / 2, -s / 2, -s * 3],
				[s / 2, s / 2, s / 2],
			);

			const render = () => scene.render(kCvs, { wireframe: WIREFRAME });
			const kCvs = new KCanvas(cvs);
			scene.putKObj(cube);

			const WIREFRAME = true;

			cvs.onmousemove = (ev) => {
				// MO FIX GIMBOL LOCK
				scene.camera.rot[2] = (ev.offsetY / cvs.height - 0.5) * Math.PI;
				scene.camera.rot[1] = (ev.offsetX / cvs.width - 0.5) * Math.PI * 4;
				render();
			};

			const rotCube = (timestamp) => {
				const n = timestamp / 2000;
				cube.transform = Mat.rot([n, n * 0.3, 0]).homo();
				render();
				requestAnimationFrame(rotCube);
			};
			requestAnimationFrame(rotCube);

			const d = 20;
			cvs.onkeydown = (ev) => {
				const k = ev.key.toLowerCase();
				let a = 0;
				if (k === "s" || k === "a" || k === "q") a = d;
				if (k === "w" || k === "d" || k === "e") a = -d;
				if (k === "n") {
					let o = 0.05;
					function an() {
						scene.camera.fov -= o;
						render();
						o *= 0.8;
						if (o > 0.001) requestAnimationFrame(an);
					}
					an();
				}
				if (k === "m") {
					let o = 0.05;
					function an() {
						scene.camera.fov += o;
						render();
						o *= 0.8;
						if (o > 0.001) requestAnimationFrame(an);
					}
					an();
				}
				function mv(c, b) {
					scene.camera.pos[c] += b;
					render();
					b *= 0.9;
					if (Math.abs(b) > 0.1) requestAnimationFrame(() => mv(c, b));
				}
				let c = 0;
				if (k === "w" || k === "s") c = 2;
				if (k === "d" || k === "a") c = 0;
				if (k === "e" || k === "q") c = 1;

				if (a !== 0) mv(c, a);
			};
		</script>
	</body>
</html>
